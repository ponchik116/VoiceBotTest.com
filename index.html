<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <title>Голос → перевод → TTS (RU → EN)</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    body{font-family:system-ui,Segoe UI,Roboto,Arial;margin:20px}
    button{padding:8px 12px;margin:6px}
    #log{white-space:pre-wrap;border:1px solid #ddd;padding:10px;min-height:120px}
    label{margin-left:12px}
  </style>
</head>
<body>
  <h2>Говорите (RU) — переводит на EN и воспроизводит</h2>

  <div>
    <button id="startBtn">Начать</button>
    <button id="stopBtn" disabled>Остановить</button>
    <label>
      TTS-голос (EN):
      <select id="voiceSelect"></select>
    </label>
    <label style="margin-left:12px">
      Translate API:
      <select id="apiSelect">
        <option value="libre">LibreTranslate (public)</option>
        <option value="none">— не переводить —</option>
      </select>
    </label>
  </div>

  <div id="status">Статус: ожидаю</div>
  <div id="log" aria-live="polite"></div>

<script>
const startBtn = document.getElementById('startBtn');
const stopBtn = document.getElementById('stopBtn');
const status = document.getElementById('status');
const log = document.getElementById('log');
const voiceSelect = document.getElementById('voiceSelect');
const apiSelect = document.getElementById('apiSelect');

const STOP_WORD = 'чеснок';
let recognition, voices = [], selectedVoiceName = null;
let stopRequested = false;

// SpeechRecognition init
const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
if (!SpeechRecognition) {
  status.textContent = 'SpeechRecognition не поддерживается в этом браузере.';
  startBtn.disabled = true;
} else {
  recognition = new SpeechRecognition();
  recognition.lang = 'ru-RU';
  recognition.interimResults = false;
  recognition.continuous = false;
}

// Load voices
function loadVoices() {
  voices = speechSynthesis.getVoices() || [];
  voiceSelect.innerHTML = '';
  voices.forEach(v => {
    // show only English-capable voices and allow others too
    const opt = document.createElement('option');
    opt.value = v.name;
    opt.textContent = `${v.name} (${v.lang})${v.default ? ' — default' : ''}`;
    voiceSelect.appendChild(opt);
  });
  if (!selectedVoiceName && voices.length) {
    // pick a likely English voice if present
    const enVoice = voices.find(v => v.lang && v.lang.startsWith('en')) || voices[0];
    selectedVoiceName = enVoice.name;
  }
  if (selectedVoiceName) voiceSelect.value = selectedVoiceName;
}
loadVoices();
speechSynthesis.onvoiceschanged = loadVoices;
voiceSelect.addEventListener('change', ()=> selectedVoiceName = voiceSelect.value);

// Simple logger
function logMsg(s) {
  log.textContent = `${new Date().toLocaleTimeString()} — ${s}\n` + log.textContent;
}

// Translate function — LibreTranslate public instance
async function translateText(text, from='ru', to='en') {
  if (apiSelect.value === 'none') return text;
  try {
    const res = await fetch('https://libretranslate.com/translate', {
      method: 'POST',
      headers: {'Content-Type':'application/json'},
      body: JSON.stringify({q: text, source: from, target: to, format: 'text'})
    });
    if (!res.ok) throw new Error('translate error ' + res.status);
    const j = await res.json();
    return j.translatedText;
  } catch (e) {
    console.warn('Translation failed', e);
    return text; // fallback — вернуть оригинал
  }
}

// Speak with selected voice (explicitly set voice)
function speakText(text) {
  if (!text) return Promise.resolve();
  return new Promise(resolve => {
    const utter = new SpeechSynthesisUtterance(text);
    const currentVoices = speechSynthesis.getVoices() || [];
    let v = currentVoices.find(x => x.name === selectedVoiceName);
    if (!v) {
      v = currentVoices.find(x => x.lang && x.lang.startsWith('en')) || currentVoices[0];
      if (v) selectedVoiceName = v.name;
      if (voiceSelect) voiceSelect.value = selectedVoiceName;
    }
    if (v) utter.voice = v;
    utter.rate = 1;
    utter.pitch = 1;
    utter.onend = () => resolve();
    utter.onerror = () => resolve();
    speechSynthesis.speak(utter);
  });
}

// Recognition handlers
if (recognition) {
  recognition.onstart = () => {
    status.textContent = 'Слушаю...';
    startBtn.disabled = true;
    stopBtn.disabled = false;
  };
  recognition.onerror = (e) => {
    console.warn('rec error', e);
    if (!stopRequested) setTimeout(()=>{ try{ recognition.start(); }catch{} }, 250);
  };
  recognition.onend = () => {
    if (stopRequested) {
      status.textContent = 'Остановлено';
      startBtn.disabled = false;
      stopBtn.disabled = true;
      return;
    }
    try { recognition.start(); } catch(e) {}
  };
  recognition.onresult = async (evt) => {
    const text = (evt.results[0][0].transcript || '').trim();
    if (!text) return;
    logMsg('RU: ' + text);
    if (text.toLowerCase().split(/\s+/).includes(STOP_WORD)) {
      logMsg('Стоп-слово: остановка');
      stopRequested = true;
      try { recognition.stop(); } catch(e){}
      speechSynthesis.cancel();
      status.textContent = 'Остановлено (услышано стоп-слово)';
      startBtn.disabled = false;
      stopBtn.disabled = true;
      return;
    }

    // translate and speak
    status.textContent = 'Перевожу...';
    const translated = await translateText(text, 'ru', 'en');
    logMsg('EN: ' + translated);
    status.textContent = 'Говорю перевод...';
    await speakText(translated);
    status.textContent = 'Слушаю...';
  };
}

// Buttons
startBtn.addEventListener('click', async () => {
  if (!recognition) return;
  stopRequested = false;
  log.textContent = '';
  status.textContent = 'Загрузка голосов...';
  // ensure voices loaded
  await new Promise(res => {
    loadVoices();
    if (speechSynthesis.getVoices().length) return res();
    speechSynthesis.addEventListener('voiceschanged', function fc(){ loadVoices(); speechSynthesis.removeEventListener('voiceschanged', fc); res(); });
    setTimeout(res, 1500);
  });
  status.textContent = 'Слушаю...';
  try { recognition.start(); } catch(e) {}
});

stopBtn.addEventListener('click', () => {
  stopRequested = true;
  try { recognition.stop(); } catch(e) {}
  speechSynthesis.cancel();
  status.textContent = 'Остановлено вручную';
  startBtn.disabled = false;
  stopBtn.disabled = true;
});
</script>
</body>
</html>
