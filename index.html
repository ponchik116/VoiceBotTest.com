<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <title>Говоришь — озвучивает каждое слово</title>
  <style>
    body{font-family:system-ui,Segoe UI,Roboto,Arial;margin:28px}
    button{font-size:15px;padding:8px 12px;margin:6px}
    #status{margin-top:12px;color:#333'}
    #log{margin-top:12px;padding:10px;border:1px solid #ddd;min-height:60px;white-space:pre-wrap}
  </style>
</head>
<body>
  <h2>Каждое слово воспроизводится отдельно (стоп-слово: "чеснок")</h2>

  <div>
    <button id="startBtn">Начать</button>
    <button id="stopBtn" disabled>Остановить</button>
    <label style="margin-left:12px">
      Голос TTS:
      <select id="voiceSelect"></select>
    </label>
  </div>

  <div id="status">Статус: ожидаю</div>
  <div id="log" aria-live="polite"></div>

<script>
const startBtn = document.getElementById('startBtn');
const stopBtn = document.getElementById('stopBtn');
const status = document.getElementById('status');
const log = document.getElementById('log');
const voiceSelect = document.getElementById('voiceSelect');

let recognition;
let recognizing = false;
let stopRequested = false;
const STOP_WORD = 'чеснок';

// Инициализация SpeechRecognition
const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
if (!SpeechRecognition) {
  status.textContent = 'SpeechRecognition не поддерживается в этом браузере.';
  startBtn.disabled = true;
} else {
  recognition = new SpeechRecognition();
  recognition.lang = 'ru-RU';
  recognition.interimResults = false; // хотим только финальные результаты
  recognition.continuous = false; // краткие фразы — остановка по финалу; мы вручную рестартим
}

// Загрузка голосов
function populateVoices() {
  const voices = speechSynthesis.getVoices();
  voiceSelect.innerHTML = '';
  voices.forEach(v => {
    const opt = document.createElement('option');
    opt.value = v.name;
    opt.textContent = `${v.name} (${v.lang})${v.default ? ' — default' : ''}`;
    voiceSelect.appendChild(opt);
  });
}
populateVoices();
if (speechSynthesis.onvoiceschanged !== undefined) {
  speechSynthesis.onvoiceschanged = populateVoices;
}

function logMsg(s) {
  log.textContent = `${new Date().toLocaleTimeString()} — ${s}\n` + log.textContent;
}

// Воспроизведение текста
function speakText(text, cb) {
  if (!text) { if (cb) cb(); return; }
  const utter = new SpeechSynthesisUtterance(text);
  const chosen = voiceSelect.value;
  const voices = speechSynthesis.getVoices();
  if (chosen) {
    const v = voices.find(x => x.name === chosen);
    if (v) utter.voice = v;
  }
  utter.rate = 1;
  utter.pitch = 1;
  utter.onend = () => { if (cb) cb(); };
  utter.onerror = () => { if (cb) cb(); };
  speechSynthesis.cancel();
  speechSynthesis.speak(utter);
}

// Обработчики распознавания
if (recognition) {
  recognition.onstart = () => {
    recognizing = true;
    status.textContent = 'Слушаю...';
    startBtn.disabled = true;
    stopBtn.disabled = false;
  };

  recognition.onerror = (e) => {
    console.warn('recognition error', e);
    // попытаемся перезапустить, если не запрошен стоп
    if (!stopRequested) {
      setTimeout(() => { try { recognition.start(); } catch(_){} }, 200);
    }
  };

  recognition.onend = () => {
    recognizing = false;
    if (stopRequested) {
      status.textContent = 'Остановлено';
      startBtn.disabled = false;
      stopBtn.disabled = true;
      return;
    }
    // автоматически рестартим, чтобы слушать следующее слово
    try {
      recognition.start();
    } catch (e) { /* ignore */ }
  };

  recognition.onresult = (evt) => {
    const res = evt.results[0][0].transcript.trim();
    if (!res) return;
    logMsg('Распознано: ' + res);
    // Проверка стоп-слова (регистронезависимо, учитываем только слово)
    if (res.toLowerCase().split(/\s+/).includes(STOP_WORD)) {
      logMsg('Стоп-слово обнаружено — остановка');
      stopRequested = true;
      try { recognition.stop(); } catch(_) {}
      speechSynthesis.cancel();
      status.textContent = 'Остановлено (услышано стоп-слово)';
      startBtn.disabled = false;
      stopBtn.disabled = true;
      return;
    }
    // Воспроизводим распознанный текст, затем сразу рестартим (в onend распознавания мы уже рестартим)
    // Чтобы минимизировать прерывания, запускаем speak и не ждём окончания для рестарта — recognition.onend сделает рестарт.
    speakText(res);
  };
}

// Кнопки
startBtn.addEventListener('click', () => {
  if (!recognition) return;
  stopRequested = false;
  log.textContent = '';
  try { recognition.start(); } catch(e) {}
});

stopBtn.addEventListener('click', () => {
  stopRequested = true;
  try { recognition.stop(); } catch(e) {}
  speechSynthesis.cancel();
  status.textContent = 'Остановлено вручную';
  startBtn.disabled = false;
  stopBtn.disabled = true;
});
</script>
</body>
</html>
